#summary Communicate with Micropendous board using Serial Port software and techniques

The latest version of this firmware is available in the latest [http://code.google.com/p/micropendous/downloads/list Micropendous Distribution] or via [http://code.google.com/p/micropendous/source/checkout SVN] in the `/Micropendous/Firmware/USBVirtualSerial_FreeRTOS` directory.

*Purpose:* USBVirtualSerial_FreeRTOS combines the [http://www.fourwalledcubicle.com/LUFA.php LUFA] USB library with the preemptive [http://www.freertos.org/ FreeRTOS] kernel to enable programming Micropendous boards without worrying about USB.  All USB functionality is hidden.  The preemptive FreeRTOS kernel allows for multitasking user code and LUFA USB functions.

*Source Code:* [http://code.google.com/p/micropendous/source/browse/trunk/Micropendous/Firmware/USBVirtualSerial_FreeRTOS View] or [http://www.Micropendous.org/Distribution Download]

*USB Mode:* Device-mode enumerating as USB Virtual Serial Port

*Targets:* [Micropendous2], [Micropendous3], or [Micropendous4], or other USB AVR boards with more than 2kbytes of SRAM.

*Status:* _Working_.  Please post any problems you encounter to the [http://groups.google.com/group/Micropendous Micropendous Group].

== Usage ==

Assuming you have completed all setup tasks in the [QuickStart] tutorial, simply compile and upload the USBVirtualSerial-FreeRTOS firmware onto your Micropendous by following the [ProgramAndTest] tutorial.

USBVirtualSerial-FreeRTOS programmed devices will enumerate as a Virtual Serial Port and any data sent to the device using [Serial] will be echoed back.

== Firmware Design ==

This firmware is based on [USBVirtualSerial].  The preemptive [http://www.freertos.org/FreeRTOS] kernel was added to allow multi-tasking and hide USB functionality from the programmer.  Standard `stdin` and `stdout/stderr` streams are created in `main()` and linked to the USB Virtual Serial Port.  This means you can use standard `printf` and `getchar` functions to read and write data over the USB connection.  Just place your code in `Main_Task()`.  See [http://www.nongnu.org/avr-libc/user-manual/group__avr__stdio.html avr-libc stdio] for detailed instructions on using these functions.

_Note:_ DO NOT alter Timer1 settings as it is used by FreeRTOS.

The example is very simple.  `haveData()` checks if data has been received from the host and then `getData()` and `sendData()` send it back over the USB serial connection.
{{{
/* Main_Task will run periodically once initialization is complete */
void MainTask(void)
{
  int tempInt = 0; // temporary storage - integer (16-bit)

  // If the host has sent data then process it

  // Example 1 - using standard IO functions
  while (haveData()) {    // need to check that data exists before processing it
    // store data temporarily then send it right back - raw binary - using standard IO functions
    tempInt = getchar();
    putchar(tempInt);
  }

  // Example 2 - using formatted standard IO functions
/*while (haveData()) {
    // as long as getchar() is returning data, process it
    printf_P(PSTR("\r\nUSBVirtualSerial\r\n")); // send a string that is constant and stored in FLASH
    tempInt = getchar(); // receive a character
    printf("Received char = %3d\r\n", tempInt); // send a string that is dynamic and stored in SRAM
    // avoid long dynamic strings as there is little SRAM
  }
*/
}

}}}

Commented out are `printf()` and `getchar()` functions which perform the same task.  Note that `printf()` is stored entirely in SRAM so it is best to use `printf_P(PSTR("...");` to store any constant strings.

FreeRTOS use is accomplished by using `xTaskCreate()` to add `USB`, `CDC`, and `Main_Task` functions to the FreeRTOS kernel and then starting the kernel with `vTaskStartScheduler()` in `main()`.  Thus FreeRTOS handles the USB and user functions and separates their functionality.  User code (even if it busy-loops) cannot interfere with USB functionality as FreeRTOS pre-empts it by running USB functions periodically.

On the host side, `serialpy.py` is an example of serial communication and is explained in [Serial].