#summary USB Virtual Serial to HD44780 Character LCD Interface

The latest version of this firmware is available in the latest [http://code.google.com/p/micropendous/downloads/list Micropendous Distribution] or via [http://code.google.com/p/micropendous/source/checkout SVN] in the `/Micropendous/Firmware/USBVirtualSerial-LCD ` directory.

*Purpose:* Display text on a [http://en.wikipedia.org/wiki/HD44780_Character_LCD HD44780] character LCD display.

*Source Code:* [http://code.google.com/p/micropendous/source/browse/trunk/Micropendous/Firmware/USBVirtualSerial-LCD View] or [http://www.Micropendous.org/Distribution Download]

*Targets:* [Micropendous1], [Micropendous2], [Micropendous3], [Micropendous4] or any USB AVR based hardware

*USB Mode:* Device-mode enumerating as USB Virtual Serial Port 

*Status:* _Working_

= Uasge =

=== [Micropendous] ===

http://micropendous.googlecode.com/svn/trunk/Micropendous/Design/Micropendous/Micropendous_Picture-LCD_Connected.jpg

=== [Micropendous2] ===

http://micropendous.googlecode.com/svn/trunk/Pictures/USBVirtualSerial-LCD_Picture.jpg

Compile and load the USBVirtualSerial-LCD firmware onto your USB AVR by following the [ProgramAndTest] tutorial.

The HD44780 LCD pictured is a [http://www.lumex.com/specs/LCM-S01602DTR%20M.pdf Lumex LCM-S01602DTR].  It can be purchased from [http://search.digikey.com/scripts/DkSearch/dksus.dll?Detail&name=67-1781-ND Digi-Key.com] along with a [http://search.digikey.com/scripts/DkSearch/dksus.dll?Detail&name=609-2227-ND breakable right-angle header] which you will need to solder to the LCD.  It is connected to a [Micropendous2] set to run at 5V.

== Connecting a Micropendous Board to a HD44780 LCD ==

To save pins the 4-bit HD44780 communication protocol is used.  You can modify the port being used and associated pins in `/Micropendous/Firmware/USBVirtualSerial-LCD/lcdconf.h`.  This is explained later.

The connections are as follows for the standard firmware:

|| Micropendous  || LCD Name || LCD Pin ||
|| GND || GND || 1 ||
|| Vcc || Vcc || 2 ||
|| GND || Contrast || 3 ||
|| PD0  || RS || 4 ||
|| PD1  || RW || 5 ||
|| PD2  || E || 6 ||
|| PD4 || Data4 || 11 ||
|| PD5 || Data5 || 12 ||
|| PD6 || Data6 || 13 ||
|| PD7 || Data7 || 14 ||

== Testing ==

Connect your Micropendous board to your PC.  Connect to the board with a serial port terminal following the [Serial] instructions.  Anything you type will echo back to the terminal and will also be displayed on the LCD.

= Firmware Design =

The goal is to use [http://ccrma.stanford.edu/courses/250a/docs/avrlib/html/index.html AVRlib's] character LCD functions with data sent to the _Virtual Serial Port_ made up of the Micropendous running modified [USBVirtualSerial] firmware.  The following steps are how the [http://code.google.com/p/micropendous/source/browse/trunk/Micropendous/Firmware/USBVirtualSerial-LCD USBVirtualSerial-LCD] firmware was created.

The first step is to copy [USBVirtualSerial] firmware to a new `USBVirtualSerial-LCD` directory and rename `USBVirtualSerial.c` and `USBVirtualSerial.h`.  The `#include` line near the top of our new `USBVirtualSerial-LCD.c` must be edited for the renamed files.

Examine AVRlib's example code for [http://code.google.com/p/micropendous/source/browse/#svn/trunk/Micropendous/libs/avrlib/examples/lcd LCD functionality] to determine what files are needed to use the LCD code.

Files `global.h` and `lcdconf.h` must be copied to the `USBVirtualSerial-LCD` directory.

AVRlib's `rprintf.c, lcd.c, and timer.c` will need to be included for proper functionality of the LCD code.  Open the `makefile` for editing in an editor that does not add formatting (such as [SettingUpProgrammersNotepad Programmer's Notepad]).  Set `TARGET` to use the renamed code base, and `SRC` to include AVRlib's files during compilation.

{{{
TARGET = USBVirtualSerial-LCD
}}}

{{{
AVRLIB_PATH = ../../libs/avrlib

SRC = $(TARGET).c            \
    Descriptors.c            \
    Lib/RingBuff.c           \
    $(AVRLIB_PATH)/rprintf.c \
    $(AVRLIB_PATH)/lcd.c     \
    $(AVRLIB_PATH)/timer.c   \
...
}}}

AVRlib also requires some [http://en.wikipedia.org/wiki/Header_file header files].  Add the following `#includes` to `USBVirtualSerial-LCD.h`:

{{{
  #include "global.h"
  #include "lcdconf.h"
  #include <lcd.h>
  #include <timer.h>
  #include <rprintf.h>
}}}

To make sure the compiler can find the above header files the `makefile` must also have AVRlib's directory in the list of header include directories:
{{{
EXTRAINCDIRS = $(LUFA_PATH)/ $(AVRLIB_PATH)/
}}}

For the LCD code to work the USB AVRs and your particular HD44780-based LCD display `lcdconf.h` must be edited.  The chosen display has 2 lines of 16 characters.  Data and control signals are sent over `PortD` using a 4bit interface.  This configuration was chosen as `PortD` exists on all USB AVRs and will work with the [http://www.atmel.com/dyn/products/tools_card.asp?tool_id=3879 AT90USBKey].

{{{
#ifdef LCD_PORT_INTERFACE
    #define LCD_CTRL_PORT   PORTD
    #define LCD_CTRL_DDR    DDRD
    #define LCD_CTRL_RS     0
    #define LCD_CTRL_RW     1
    #define LCD_CTRL_E      2
    // port you will use for data lines
    #define LCD_DATA_POUT   PORTD
    #define LCD_DATA_PIN    PIND
    #define LCD_DATA_DDR    DDRD
    // access mode you will use (default is 8bit unless 4bit is selected)
    #define LCD_DATA_4BIT
    ...

#define LCD_LINES           2
#define LCD_LINE_LENGTH     16

}}}


`global.h` is edited to remove `F_CPU` defines, as the `makefile` defines this variable.
{{{
#include <avrlibdefs.h>
#include <avrlibtypes.h>

#define CYCLES_PER_US ((F_CPU+500000)/1000000)  // cpu cycles per microsecond
}}}

In `main()` of `USBVirtualSerial-LCD.c`, the LCD functions must be initialized:

{{{
  lcdInit();
  rprintfInit(lcdDataWrite); // direct rprintf to LCD
  lcdClear();  // clear the LCD
  rprintf("GO AVRlib!");
}}}

Finally, while data from the host is in the input buffer, send it to the LCD and back to the host.  Make sure characters past the end of the second line get sent back to the start.

{{{
volatile uint8_t character_count = 0;
volatile uint8_t current_line = 0;

void Main_Task(void)
{
  uint8_t tempChar = 0;   // temporary storage - unsigned 8-bit integer

  // while the buffer has elements, write them to the LCD
  while (haveData()) {
    /* Basically each character is written sequentially, first to the top line, then to the next, etc... */
    tempChar = getchar();
    putchar(tempChar); // send char back for echo'ing on terminal
    character_count++;
    rprintfChar(tempChar); // print char to the LCD
    // once we hit the end of a single line, loop to next line
    if (character_count >= LCD_LINE_LENGTH) {
      character_count = 0;
      current_line++;
      // once we hit the end of the last line, loop to the first line
      if (current_line >= LCD_LINES) {
        current_line = 0;
      }
      lcdGotoXY(0, current_line);
    }
  }
}

}}}

The firmware will not function unless an LCD display is connected as `lcdInit()` blocks.

=== Using AVRlib's LCD Functions ===
{{{
/* Print some text to the LCD */
rprintf("Hello there")


/* Print value of myValue in base 10 using 5 digits, it is
 * FALSE that this value can be negative (it is positive),
 * and pad the value to 5 digits using 0s if necessary
 */
rprintfNum(10, 5, FALSE, '0', myValue);


/* Move to a particular cursor location */
/* lcdGotoXY(cursorPositionInLine, whichLine); */
/* In this case the 3rd position of line 2 (counting starts at 0) */
lcdGotoXY(2, 1);


/* Clear the LCD */
lcdClear();


/* Text and Numbers, the following would print "Value = 12345 of something" */
uint16_t myValue = 12345;
rprintf("Value = ")
rprintfNum(10, 5, FALSE, '0', myValue);
rprintf(" of something")

}}}

Do not use `\n` or `\r\n` newline characters as they are not properly handled.  Use `lcdGotoXY()` to position your text.

= Connecting an [http://www.atmel.com/dyn/products/tools_card.asp?tool_id=3879 AT90USBKey] to a HD44780 LCD =

http://micropendous.googlecode.com/svn/trunk/Pictures/USBVirtualSerial_LCD-AT90USBKey.jpg

The current USBVirtualSerial-LCD firmware will work with an AT90USBKey.  However, most HD44780 LCDs run at 5V while the AT90USBKey runs at 3.3V.  You must source 5V and its' corresponding GND from somewhere else (such as a [http://en.wikipedia.org/wiki/Universal_Serial_Bus#Connector_types USB connector]) and connect them to your LCD's Vcc and GND pins.  All non-Vcc other connections are standard.

= Connecting a Micropendous to a HD44780 LCD using 2 Ports =

The version that uses a full 8-bit data bus is slightly faster an is available in the `USBVirtualSerial-LCD_2PortVersion` directory.  It is used on the obsolete [http://code.google.com/p/opendous/wiki/AD_Micropendous1BaseDevelopmentBoard Micropendous1-Base Development Board].

To enable 8-Bit mode you must comment out the `USE_4BIT_LCD_INTERFACE` line in the `makefile`:
{{{
  LUFA_OPTS += -D USE_4BIT_LCD_INTERFACE
}}}
Should become:
{{{
  #LUFA_OPTS += -D USE_4BIT_LCD_INTERFACE
}}}

The connections are as follows:

|| Micropendous  || LCD Name || LCD Pin ||
|| GND || GND || 1 ||
|| Vcc || Vcc || 2 ||
|| GND || Contrast || 3 ||
|| PC7  || RS || 4 ||
|| PC6  || RW || 5 ||
|| PC5  || E || 6 ||
|| PB0 (^SS) || Data0 || 7 ||
|| PB1 (SCK) || Data1 || 8 ||
|| PB2 (MOSI) || Data2 || 9 ||
|| PB3 (MISO) || Data3 || 10 ||
|| PB4 || Data4 || 11 ||
|| PB5 || Data5 || 12 ||
|| PB6 || Data6 || 13 ||
|| PB7 || Data7 || 14 ||

The key settings that determine functionality are in `Micropendous/Firmware/USBVirtualSerial-LCD/lcdconf.h`:

{{{
#ifdef LCD_PORT_INTERFACE
  #ifndef LCD_CTRL_PORT
    // port and pins you will use for control lines
    #define LCD_CTRL_PORT   PORTC
    #define LCD_CTRL_DDR    DDRC
    #define LCD_CTRL_RS     7
    #define LCD_CTRL_RW     6
    #define LCD_CTRL_E      5
  #endif
  #ifndef LCD_DATA_POUT
    // port you will use for data lines
    #define LCD_DATA_POUT   PORTB
    #define LCD_DATA_PIN    PINB
    #define LCD_DATA_DDR    DDRB
    // access mode you will use (default is 8bit unless 4bit is selected)
    //#define LCD_DATA_4BIT // commented out to select 8-Bit
  #endif
#endif
}}}