#summary something

DRAFT!

The latest version of this firmware is available in the latest [http://code.google.com/p/micropendous/downloads/list Micropendous Distribution] or via [http://code.google.com/p/micropendous/source/checkout SVN] in the `/Micropendous/Firmware/SOMETHING` directory.

*Targets*: [Micropendous1], [Micropendous2], [Micropendous3], [Micropendous4] or any USB AVR based hardware

*USB Mode*: Device-class enumerating as 

*Status*: Working


== Usage ==

How to use.

== Firmware Design ==

How it was coded.


== Introduction ==

The HD44780 LCD pictured below is a [http://www.lumex.com/pdf/LCM-S01602DTR+M.pdf Lumex LCM-S01602DTR].  It can be purchased from [http://search.digikey.com/scripts/DkSearch/dksus.dll?Detail&name=67-1781-ND Digi-Key.com] along with a [http://search.digikey.com/scripts/DkSearch/dksus.dll?Detail&name=609-2227-ND breakable right-angle header] which you will need to solder to the LCD.


http://micropendous.googlecode.com/svn/trunk/Pictures/USBVirtualSerial-LCD-1.jpg

== Table of Contents ==

 * Connecting an Micropendous to a HD44780 LCD
 * Usage
 * Connecting an Micropendous to a HD44780 LCD using 2 Ports
 * Firmware Design Overview
 * Using Python to Control the LCD

== Connecting an Micropendous to a HD44780 LCD ==

To save pins the 4-bit HD44780 communication protocol is used.  You can modify the port being used and associated pins in `/Micropendous/Firmware/USBVirtualSerial-LCD/lcdconf.h`.

The connections are as follows for the standard firmware:

|| Micropendous  || LCD Name || LCD Pin ||
|| GND || GND || 1 ||
|| Vcc || Vcc || 2 ||
|| GND || Contrast || 3 ||
|| PB0  || RS || 4 ||
|| PB1  || RW || 5 ||
|| PB2  || E || 6 ||
|| PB4 || Data4 || 11 ||
|| PB5 || Data5 || 12 ||
|| PB6 || Data6 || 13 ||
|| PB7 || Data7 || 14 ||



== Usage ==

Plug the Micropendous board into your PC.  Connect to the board with a serial port terminal (instructions for [SerialPortUsageWindows Windows] and [SerialPortUsageLinux Linux] are available).  Anything you type will echo back to the terminal and will also be displayed on the LCD.

== Connecting an Micropendous to a HD44780 LCD using 2 Ports ==

The version that uses a full 8-bit data bus is slightly faster.

In directory:

The connections are as follows:

|| Micropendous  || LCD Name || LCD Pin ||
|| GND || GND || 1 ||
|| Vcc || Vcc || 2 ||
|| GND || Contrast || 3 ||
|| PC7  || RS || 4 ||
|| PC6  || RW || 5 ||
|| PC5  || E || 6 ||
|| PB0 (^SS) || Data0 || 7 ||
|| PB1 (SCK) || Data1 || 8 ||
|| PB2 (MOSI) || Data2 || 9 ||
|| PB3 (MISO) || Data3 || 10 ||
|| PB4 || Data4 || 11 ||
|| PB5 || Data5 || 12 ||
|| PB6 || Data6 || 13 ||
|| PB7 || Data7 || 14 ||


== Firmware Design Overview ==

The goal is to use [http://ccrma.stanford.edu/courses/250a/docs/avrlib/html/index.html AVRlib's] character LCD functions with data sent to the _Virtual Serial Port_ made up of the Micropendous running modified [USBtoSerial] firmware.

The first step is to examine AVRlib's example code for [http://code.google.com/p/micropendous/source/browse/#svn/trunk/Micropendous/libs/avrlib/examples/lcd LCD functionality] to determine what files are needed to use the LCD code.

Files `global.h` and `lcdconf.h` must be copied to the `USBtoSerial` directory.

Notice that AVRlib's `rprintf.c, lcd.c, and timer.c` will need to be included for proper functionality of the LCD code.  Open the `makefile` for editing in an editor that does not add formatting.  Set `TARGET` to use the renamed code base, and `SRC` to include AVRlib's files during compilation.

{{{
TARGET = USB_Serial_Port-LCD
}}}

{{{
SRC = $(TARGET).c                   \
          Descriptors.c             \
          RingBuff.c                \
          ../../avrlib/rprintf.c    \
          ../../avrlib/lcd.c        \
          ../../avrlib/timer.c      \
...

}}}

Next `lcdconf.h` must be edited to work with the Micropendous and your particular HD44780-based LCD display.  This particular display has 2 lines of 20 characters.  Data is sent over `PortB` and control signals are on `PortC`.  This configuration was chosen as `PortD` has an external pull-up resistor on PD7 (HWB), to disable bootloader during reset.

{{{
#ifdef LCD_PORT_INTERFACE
    #define LCD_CTRL_PORT   PORTC
    #define LCD_CTRL_DDR    DDRC
    #define LCD_CTRL_RS     7
    #define LCD_CTRL_RW     6
    #define LCD_CTRL_E      5
    // port you will use for data lines
    #define LCD_DATA_POUT   PORTB
    #define LCD_DATA_PIN    PINB
    #define LCD_DATA_DDR    DDRB
    ...

#define LCD_LINES           2
#define LCD_LINE_LENGTH     20

}}}


Next `global.h` must be edited to remove `F_CPU` defines, as the `makefile` defines this variable.


Next, in `main()` of `USB_Serial_Port-LCD.c`, the LCD functions must be initialized:

{{{
    lcdInit();
    rprintfInit(lcdDataWrite); // direct rprintf to LCD
    rprintf("Welcome to AVRlib!");
    lcdClear();
}}}

Finally, each time data is received from the host, send it to the LCD.  Make sure characters past the end of the second line get sent back to the start.

{{{
TASK(CDC_Task)
{
    ...
    if (USB_IsConnected)
    {
        ....
        if (Endpoint_ReadWriteAllowed())
            ...
            while (Endpoint_BytesInEndpoint())
                ...
                while (!((BUFF_STATICSIZE - Rx_Buffer.Elements)));
                        
                    Buffer_StoreElement(&Rx_Buffer, Endpoint_Read_Byte());

                    tempchar = Buffer_GetElement(&Rx_Buffer);
                    Buffer_StoreElement(&Tx_Buffer, tempchar); // echo character back
                    rprintfChar(tempchar);
                    character_count++;
                    if (character_count >= LCD_LINE_LENGTH) {
                        character_count = 0;
                        current_line++;
                        if (current_line >= LCD_LINES) {
                            current_line = 0;
                        }
                        lcdGotoXY(0, current_line);
                    }
}}}

Note that there are also some global `define`s, for `character_count` and `current_line`.

The firmware will not function unless an LCD display is connected as `lcdInit()` blocks.
