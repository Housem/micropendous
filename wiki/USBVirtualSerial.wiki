#summary Communicate with Micropendous board using Serial Port software and techniques

The latest version of this firmware is available in the latest [http://code.google.com/p/micropendous/downloads/list Micropendous Distribution] or via [http://code.google.com/p/micropendous/source/checkout SVN] in the `/Micropendous/Firmware/USBVirtualSerial` directory.

*Purpose:* USBVirtualSerial is a demonstration of USB Virtual Serial Port communication.  Data sent to a device loaded with this firmware will be echoed back.

*Source Code:* [http://code.google.com/p/micropendous/source/browse/trunk/Micropendous/Firmware/USBVirtualSerial View] or [http://www.Micropendous.org/Distribution Download]

*Targets:* [Micropendous1], [Micropendous2], [Micropendous3], or [Micropendous4], or other USB AVR boards

*USB Mode:* Device-mode enumerating as USB Virtual Serial Port

*Status:* _Working_.  Please post any problems you encounter to the [http://groups.google.com/group/Micropendous Micropendous Group].

== Usage ==

Assuming you have completed all setup tasks in the [QuickStart] tutorial, simply compile and upload the USBVirtualSerial firmware onto your Micropendous board by following the [ProgramAndTest] tutorial.

USBVirtualSerial programmed devices will enumerate as a Virtual Serial Port and any data sent to the device using [Serial] will be echoed back.

== Firmware Design ==

This firmware is based on [http://www.fourwalledcubicle.com/LUFA.php LUFA]'s [USBtoSerial].  The main difference is that UART communication was replaced with loopback code.  All UART settings can be reused for your own firmware's parameters by editing the `Reconfigure()` function.

Standard `stdin` and `stdout/stderr` streams are created in `main()` and linked to the USB Virtual Serial Port.  This means you can use standard `printf` and `getchar` functions to read and write data over the USB connection.  Just place your code in `Main_Task()` which runs periodically.  See [http://www.nongnu.org/avr-libc/user-manual/group__avr__stdio.html avr-libc stdio] for detailed instructions on using these functions.

Note that your code should not busy-loop or block as this will interfere with USB functionality.  To avoid this issue, use [USBVirtualSerial_FreeRTOS].

On the host side, `serialpy.py` is an example of serial communication and is explained in [Serial].

The following is the core of this firmware and where your code should be placed.

{{{
/* Main_Task will run periodically once initialization is complete */
void MainTask(void)
{
  int count = 0;

  // If the host has sent data then process it

  // Throughput is maximized if the full EP buffer is read and sent each time
  // Throughput approaches CDC_TXRX_EPSIZE kbytes/second and depends on transfer size from host 
  if ((count = fread(&buffer, 1, CDC_TXRX_EPSIZE, &USBSerialStream)) > 0) {
    fwrite(&buffer, 1, count, &USBSerialStream);
  }


  if (count == 14) {
    // Examples of using formatted standard IO functions

    // 1) send a string that is constant and stored in FLASH
    fprintf_P(&USBSerialStream, PSTR("\r\nUSBVirtualSerial\r\n"));

    // 2) send a string that is dynamic and stored in SRAM
    fprintf(&USBSerialStream, "Received count = %3d\r\n", count);
  }
}
}}}

The above example is very simple.  `haveData()` checks if data has been received from the host and then [http://www.nongnu.org/avr-libc/user-manual/group__avr__stdio.html stdio] functions `getchar()` and `putchar(...)` are used to read and resend the data over the USB serial connection.

You can also use `printf(...)` functions but note that `printf()` is stored entirely in SRAM so it is best to use `printf_P(PSTR("...");` to store and print any constant strings.  See the [http://groups.google.com/group/micropendous/web/printf-usage printf tutorial] for more information.