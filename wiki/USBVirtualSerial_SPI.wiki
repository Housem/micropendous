#summary USB Virtual Serial to SPI Interface

The latest version of this firmware is available in the latest [http://code.google.com/p/micropendous/downloads/list Micropendous Distribution] or via [http://code.google.com/p/micropendous/source/checkout SVN] in the `/Micropendous/Firmware/USBVirtualSerial-SPI` directory.

*Purpose:* Communicate with electronic devices over the [http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus SPI] interface.

*Source Code:* [http://code.google.com/p/micropendous/source/browse/trunk/Micropendous/Firmware/USBVirtualSerial-SPI View] or [http://www.Micropendous.org/Distribution Download]

*Targets:* [Micropendous1], [Micropendous2], [Micropendous3], [Micropendous4] or any USB AVR based hardware

*USB Mode:* Device-mode enumerating as USB Virtual Serial Port

*Status:* _Working_

= Usage =

http://micropendous.googlecode.com/svn/trunk/Pictures/USBVirtualSerial-SPI_Picture.jpg

Compile and load the USBVirtualSerial_SPI firmware onto your USB AVR by following the [ProgramAndTest] tutorial.

== Pinout ==

|| *Micropendous* || *SPI*        ||
|| `PB0(^SS)`     || `^CS`        ||
|| `PB1(SCK)`     || `SCK`        ||
|| `PB2(MOSI)`    || `MOSI`       ||
|| `PB3(MISO)`    || `MISO`       ||
|| `GND`          || `GND`+`AGND` ||
|| `Vcc`          || `Vcc`+`AVcc` ||



== Changing Settings ==

USBVirtualSerial-SPI firmware was implemented over standard USBVirtualSerial firmware.  This allows changing [http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus SPI] parameters by altering the serial port configuration.

Changing the "Line Coding"/"bytesize" will change the SPI mode: `8 bits` = _Mode0_ (Default), `7 bits` = _Mode1_ , `6 bits` = _Mode2_ , `5 bits` = _Mode3_ .  Note that data is still sent in 8-bit bytes over SPI.

Changing "Baud-Rate" will change the SPI speed.  Defualt SPI clock speed is 8Mhz / 2 = 4MHz.  8Mhz is the assumed device clock speed.  Baud rate to SPI clock settings are: `9600` = _125kHz_ (Default), `14400` = _4MHz_, `19200` = _2MHz_, `38400` = _1MHz_, `57600` = _500kHz_, `115200` = _250kHz_, and any other value = _62.5kHz_.  Note all these values are doubled if using a 16Mhz clocked USB AVR board.

Changing "Stop-Bits" determines whether data will be MSB or LSB.  If the default `one stop bit` is selected, data will be transmitted MSB first.  Otherwise LSB.

== Testing ==

Testing functionality is very simple.  Connect the `MOSI` (*PB2*) and `MISO` (*PB3*) pins together to form a loopback.  Then plug in your Micropendous, start a serial terminal program such as _gtkterm_ or _!HyperTerminal_, and anything you type will echo back.  See [Serial] for instructions on the usage of serial ports.  Or, run the included Python throughput testing script:
{{{
python  TestThroughputUSBVirtualSerial.py  COM5  64  100
}}}

http://micropendous.googlecode.com/svn/trunk/Pictures/SPILoopback_B2B3_Micropendous4.jpg

=== 23K256 ===

The usage picture near the top of this page is of a [http://www.microchip.com/wwwproducts/Devices.aspx?dDocName=en539039 23K256] SPI SRAM IC available from [http://search.digikey.com/scripts/DkSearch/dksus.dll?Detail&name=23K256-I/P-ND many] [http://ca.mouser.com/Search/Refine.aspx?Keyword=579-23K256-I/P suppliers].  

== Python Usage ==

Here is a simple example for using USBVirtualSerial-SPI in Python.  The character `a` will be sent over SPI with the `ser.write()` command.  Note any 8-byte value can be sent in any compatible format, like `\af` for hex data.  Note that each call to `ser.write()` will cause the device to _both_ write data over SPI and read data back simultaneously.  Therefore each call to write should be accompanied by a call to read to avoid having buffering errors.  Note that sending two 8-bit bytes of data will appear over SPI as a 16-bit value.  More Python serial usage information is available in [Serial].

{{{
import serial           # for accessing the serial port on multiple platforms

ser = serial.Serial('COM3')  # open COM3 on Windows
# under Linux, find this value with dmesg look for something like  cdc_acm 2-1:1.0: ttyACM0: USB ACM device
#ser = serial.Serial('/dev/ttyACM0')

print ser               # dump all info regarding serial port being used

ser.write('a')          # write this character to the serial port as an 8-bit value
print ser.read()        # read the above data back, assuming loopback

ser.write('aa')         # write these characters to the serial port as a 16-bit value
print ser.read(2)       # read the above data back, assuming loopback

ser.close()             # release/close the serial port
}}}